// Additional data for tracking time
let lastPoint = null;
let lastTime = null;

// Updated getPosition function to include timestamp
function getPosition(event) {
  const rect = canvas.getBoundingClientRect();
  const timestamp = event.timeStamp; // Event timestamp
  if (event.touches) {
    return {
      x: event.touches[0].clientX - rect.left,
      y: event.touches[0].clientY - rect.top,
      time: timestamp,
    };
  }
  return {
    x: event.clientX - rect.left,
    y: event.clientY - rect.top,
    time: timestamp,
  };
}

// Start drawing with updated tracking
function startDrawing(event) {
  isDrawing = true;
  currentPath = [];
  const position = getPosition(event);
  currentPath.push(position);
  lastPoint = position;
  lastTime = position.time;
  ctx.beginPath();
  ctx.moveTo(position.x, position.y);
}

// Draw and calculate speed
function draw(event) {
  if (!isDrawing) return;

  const position = getPosition(event);
  const dx = position.x - lastPoint.x;
  const dy = position.y - lastPoint.y;
  const dt = position.time - lastTime;

  const distance = Math.sqrt(dx ** 2 + dy ** 2);
  const speed = dt > 0 ? (distance / dt) * 1000 : 0; // Speed in pixels/second

  // Add position and speed to current path
  currentPath.push({ x: position.x, y: position.y, speed });
  ctx.lineTo(position.x, position.y);
  ctx.stroke();

  lastPoint = position;
  lastTime = position.time;
}

// Stop drawing
function stopDrawing() {
  if (isDrawing) {
    paths.push(currentPath);
    isDrawing = false;
  }
}

// Convert strokes to G-code with speed
function strokesToGCode(strokes, maxFeedrate = 1200, liftHeight = 5) {
  let gcode = [
    "G21 ; Set units to mm",
    "G90 ; Absolute positioning",
  ];

  const scale = 0.264583; // Convert pixels to mm (96 DPI)

  for (const stroke of strokes) {
    if (stroke.length === 0) continue;

    // Lift the tool
    gcode.push(`G0 Z${liftHeight}`);

    // Move to the starting point of the stroke
    const start = stroke[0];
    gcode.push(`G0 X${(start.x * scale).toFixed(2)} Y${(start.y * scale).toFixed(2)}`);

    // Lower the tool
    gcode.push("G0 Z0");

    // Draw the stroke with variable speed
    for (let i = 1; i < stroke.length; i++) {
      const point = stroke[i];
      const speed = point.speed || 1; // Default speed if not calculated
      const feedrate = Math.min(maxFeedrate, Math.max(100, speed * 10)); // Scale speed to feedrate

      gcode.push(
        `G1 X${(point.x * scale).toFixed(2)} Y${(point.y * scale).toFixed(2)} F${feedrate.toFixed(0)}`
      );
    }
  }

  // Final lift
  gcode.push(`G0 Z${liftHeight}`);

  return gcode.join("\n");
}
